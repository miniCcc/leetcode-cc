### [12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

给定一个 `m x n` 二维字符网格 `board `和一个字符串单词 `word `。如果 `word `存在于网格中，返回` true `；否则，返回 `false `。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

例如，在下面的 3×4 的矩阵中包含单词 `"ABCCED"`（单词中的字母已标出）。

<img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img" style="zoom:67%;" />

**示例 1：**

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

**示例 2：**

```
输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```

**提示：**

- 1 <= board.length <= 200
- 1 <= board[i].length <= 200
- board 和 word 仅由大小写英文字母组成

---

**Java**

``` java
class Solution {
    boolean[][] visited;
    char[][] board;
    String word;
    int rowlen, collen;
    public boolean exist(char[][] board, String word) {
        int rowlen = board.length;
        int collen = board[0].length;
        this.board = board;
        this.word = word;
        this.rowlen = rowlen;
        this.collen = collen;
        visited = new boolean[rowlen][collen];
        for(int i = 0; i < rowlen; i++){
            for(int j = 0; j < collen; j++){
                if(helper(i, j, 0)) return true;
            }
        }
        return false;
    }
    public boolean helper(int i, int j, int index){
        if(i >= rowlen || j >= collen || i < 0 || j < 0 || visited[i][j]) return false;
        if(board[i][j] == word.charAt(index)){
            if(index == word.length() - 1) return true;
            visited[i][j] = true;
            // 千万不要写成 return helper(...) || helper(...) || helper(...) || helper(...)
            // 上面这样写会超时
            boolean ans = helper(i-1, j, index+1) || helper(i+1,j, index+1) 
                        || helper(i, j-1, index+1) || helper(i, j+1, index+1);
            visited[i][j] = false;
            return ans;
        }else return false;
    }
}
```

